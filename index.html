<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Resting State â€“ Center Cross (staged timing)</title>
  <style>
    :root{
      --bg: #ffffff;            /* background while on */
      --cross-color: #000000;   /* cross color */
      --cross-size: 9.5vmin;     /* smaller arm length (was 20vmin) */
      --cross-thickness: 4px;   /* bar thickness */
      --cursor: none;           /* hide cursor */
      --text-color: #000000;    /* instruction text color */
    }

    html, body { height: 100%; margin: 0; background: var(--bg); cursor: var(--cursor); }
    * { user-select: none; -webkit-user-select: none; }
    .stage { position: fixed; inset: 0; display: grid; place-items: center; background: var(--bg); }

    .cross { position: relative; width: var(--cross-size); height: var(--cross-size); }
    .cross::before, .cross::after {
      content: ""; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: var(--cross-color);
    }
    .cross::before { width: var(--cross-size); height: var(--cross-thickness); }
    .cross::after  { width: var(--cross-thickness); height: var(--cross-size); }

    .msg { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; text-align:center; }
    .msg__text { font-size: min(6vmin, 36px); line-height: 1.3; color: var(--text-color); padding: 2rem; }
  </style>
</head>
<body>
  <div class="stage" aria-hidden="true">
    <div class="cross" id="fixation"></div>
  </div>
  <div class="msg" id="message"><div class="msg__text" id="messageText"></div></div>

  <script>
    // Staged protocol:
    // 1) Fixation cross: 150s (2.5 min)
    // 2) Instruction text: 30s ("Now please close your eyes and rest")
    // 3) Blank white screen: 120s (2 min)
    // 4) Show "END" and exit fullscreen
    (function(){
      const params = new URLSearchParams(location.search);
      const setVar = (name, cssVar, transform) => {
        if (!params.has(name)) return;
        const raw = params.get(name);
        const val = transform ? transform(raw) : raw;
        if (val != null) document.documentElement.style.setProperty(cssVar, val);
      };

      // Allow customization
      setVar('bg', '--bg');
      setVar('color', '--cross-color');
      setVar('text', '--text-color');
      setVar('size', '--cross-size', n => `${parseFloat(n)||16}vmin`);
      setVar('thickness', '--cross-thickness', n => `${parseFloat(n)||4}px`);
      setVar('cursor', '--cursor');

      // Accept hex without '#'
      ['bg','color','text'].forEach(key => {
        const v = params.get(key);
        if (v && /^([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(v)){
          const cssVar = key==='bg'?'--bg': key==='color'?'--cross-color':'--text-color';
          document.documentElement.style.setProperty(cssVar, `#${v}`);
        }
      });

      function msFromParam(key, def){
        const v = parseFloat(params.get(key));
        return Number.isFinite(v) && v >= 0 ? Math.round(v*1000) : def;
      }
      // Durations (ms). Allow overrides via URL: d1, d2, d3
      const D1 = msFromParam('d1', 150_000); // fixation
      const D2 = msFromParam('d2', 30_000);  // instruction text
      const D3 = msFromParam('d3', 120_000); // blank

      // Elements
      const stage   = document.querySelector('.stage');
      const msgWrap = document.getElementById('message');
      const msgText = document.getElementById('messageText');

      // Fullscreen attempts
      const goFS = () => {
        const el = document.documentElement;
        if (el.requestFullscreen) el.requestFullscreen().catch(()=>{});
      };
      goFS();
      addEventListener('pointerdown', goFS, { once: true });
      addEventListener('keydown', goFS, { once: true });

      // Debug timer in console (1 Hz)
      let phase = 1; // 1=fixation, 2=instruction, 3=blank, 4=end
      let phaseStart = performance.now();
      let phaseDur = D1;
      const debugInterval = setInterval(()=>{
        const now = performance.now();
        const elapsed = Math.floor((now - phaseStart)/1000);
        const remain = Math.max(0, Math.ceil((phaseDur - (now - phaseStart))/1000));
        const names = {1:'fixation', 2:'instruction', 3:'blank', 4:'end'};
        console.log(`[rest] phase=${phase} (${names[phase]}), elapsed=${elapsed}s, remaining=${remain}s`);
      }, 1000);

      const sleep = (ms) => new Promise(res => setTimeout(res, ms));

      async function run(){
        // Phase 1: Fixation
        showFixation();
        phase = 1; phaseStart = performance.now(); phaseDur = D1;
        await sleep(D1);

        // Phase 2: Instruction
        showMessage('Now please close your eyes and rest');
        phase = 2; phaseStart = performance.now(); phaseDur = D2;
        await sleep(D2);

        // Phase 3: Blank white screen
        showBlank();
        phase = 3; phaseStart = performance.now(); phaseDur = D3;
        await sleep(D3);

        // Phase 4: END + exit fullscreen
        showMessage('END');
        phase = 4; phaseStart = performance.now(); phaseDur = 0;
        if (document.fullscreenElement && document.exitFullscreen) {
          document.exitFullscreen().catch(()=>{});
        }
        setTimeout(()=>clearInterval(debugInterval), 1500);
      }

      function showFixation(){
        if (stage) stage.style.display = 'grid';
        if (msgWrap) msgWrap.style.display = 'none';
      }
      function showMessage(text){
        if (stage) stage.style.display = 'none';
        if (msgWrap) {
          msgText.textContent = text;
          msgWrap.style.display = 'flex';
        }
      }
      function showBlank(){
        if (stage) stage.style.display = 'none';
        if (msgWrap) msgWrap.style.display = 'none';
        document.body.style.background = getComputedStyle(document.documentElement).getPropertyValue('--bg') || '#ffffff';
      }

      run();
    })();
  </script>
</body>
</html>


